## 0.객체지향 프로그래밍

----

1. 객체지향 프로그래밍

2. 클래스

3. JVM 메모리구조

4. 생성자

5. 접근제한자

6. 상속

## 1. 객체지향 프로그래밍

----

1. 객체지향 프로그래밍 (OOP, Object Oriented Programming)
   
   * 객체: 사물과 같이 유형적인 것과 개념이나 논리와 같은 무형적인 것들
   
   * 지향: 작정하거나 지정한 방향으로 나아감
   
   * 객체 모델링: 현실세계의 객체를 SW객체로 설계하는 것

2. 객체지향 프로그래밍 특징 (A PIE)
   
   * Abstraction (추상화)
   
   * Polymorphism (다형성)
   
   * Inheritance (상속)
   
   * Encapsulation (캡슐화)

## 2. 클래스

----

## 3. JVM 메모리 구조

----

1. JVM 메모리 구조
   
   * Java 언어는 메모리 관리를 개발자가 하지 않음
   
   * GC(Garbage Collection)가 메모리 관리
   
   * Garbage Collection
     
     * Heap 영역(class 영역 포함)에 생성된 메모리 관리 담당
     
     * 더 이상 사용되지 않는 객체들을 점검하여 제거
     
     * 자동적 실행 / CPU가 한가 or 메모리 부족
     
     * JVM에 의해서 실행
     
     * System.gc()를 통해 호출(시스템 영향을 줌 -> 사용X)
   
   * 객체 생성과 메모리 할당

2. static 특징
   
   * 로딩 시점
     
     * static : 클래스 로딩 시
     
     * non-static : 객체 생성 시
   
   * 메모리상의 차이
     
     * static : 클래스당 하나의 메모리 공간만 할당
     
     * non-static : 인스턴스 당 메모리가 별도로 할당
   
   * 문법적 특징
     
     * static : 클래스 이름으로 접근
     
     * non-static : 객체 생성 후 접근
   
   * static 영역에서는 non-static 영역을 직접 접근이 불가능
   
   * non-static 영역에서는 static 영역에 대한 접근 가능

## 4. 생성자

----

1. 생성자
   
   * 인스턴스가 생성될 때 최초 한번 수행되는 함수
     
     * new키워드와 함께 호출
     
     * 클래스 생성할 때 반드시 하나의 생성자 호출
     
     * 성공적으로 실행 -> 힙 영역에 객체 생성 후 -> 객체의 번지가 리턴
     
     * 필드의 초기화, 객체 생성 시 실행되어야 할 작업 작성
     
     * PascalCase로 작성하는 것이 관례
   
   * 클래스 명과 이름이 동일 (대, 소문자)
   
   * 반환 타입이 없다. (void 작성 x)
   
   * 기본(디폴트) 생성자
     
     * 클래스 내에 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
     
     * 형태 : 매개변수가 없는 형태, 클래스 명() {}
   
   * 파라미터가 있는 생성자
     
     * 생성자의 목적이 필드 초기화
     
     * 생성자 호출 시 값을 넘겨주어야 함
     
     * 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가X
   
   * 생성자 오버로딩 지원
     
     * 클래스 내에 메소드 이름이 같고, 매개변수의 타입 또는 개수가 다른 것
   
   * this
     
     * 참조 변수, 객체 자신 가리킴
     
     * this 이용 자신의 멤버 접근 가능
     
     * 지역변수와 필드의 이름이 동일할 경우 -> 필드임 식별할 수 있게 함
     
     * 객체에 대한 참조 -> static 영역에서 this 사용 X
   
   * this의 활용
     
     * this.멤버변수
     
     * this([인자값..]) : 생성자 호출
     
     * this 생성자 호출 시 제한사항
       
       * 생성자 내에서만 호출 가능
       
       * 생성자 내에서 첫번째 구문에 위치해야 함

## 5. 접근 제한자

----

1. 패키지 (package)

2. 임포트 (import)

3. 캡슐화 (Encapsulation)

4. 접근 제한자 (access modifier)
   
   * 클래스, 멤버 변수, 멤버 메서드 등의 선언부에서 접근 허용 범위 지정하는 역할의 키워드
   
   * 종류: public, protected, (default), private
   
   * 그 외 제한자
     
     * static : 클래스 레벨의 요소 설정
     
     * final : 요소 더 이상 수정할 수 없게
     
     * abstract : 추상 메서드 및 추상 클래스 작성
   
   * public : 모든 위치에서 접근 가능
   
   * protected : 같은 패키지에서 접근 가능. 단, 다른 패키지의 클래스와 상속관계 -> 접근 가능
   
   * default : 같은 패키지에서만 접근 가능. 기본값
   
   * private : 자신 클래스에서만 접근 가능
   
   * 클래스(외부) 사용가능 : public, default
   
   * 내부클래스, 멤버변수, 메소드 사용가능 -> 4가지 모두 가능

5. 접근자(getter) / 설정자(setter)
   
   * 클래스에서 선언된 변수 중 접근제한에 의해 접근할 수 없는 변수의 경우 ->접근하기 위한 메서드(설정자와 접근자)를 public으로 선언하여 사용

6. 싱글턴 패턴(Singleton Pattern)
   
   * 소프트웨어 디자인 패턴에서 싱글턴 패턴(Singleton pattern)을 따르는 클래스는 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴

## 6. 상속(Inheritance)

----

1. 상속
   
   * 확장성, 재사용성
     
     * 부모의 생성자와 초기화 블록은 상속X
   
   * 클래스 선언 시 extends 키워드 명시
     
     * 자바는 다중 상속 허용X, 단일 상속 지원
   
   * 관계: 부모(상위, Super) 클래스, 자식(하위, Sub) 클래스
   
   * 자식 클래스 -> 부모 클래스의 멤버변수, 메소드를 사용 가능
     
     * 단, 접근 제한자에 따라 사용 여부 달라짐
   
   * Object 클래스 -> 모든 클래스의 조상 클래스
     
     * 별도의 extends 선언 없는 클래스 -> extends Object 생략된것
   
   * super 키워드: super를 통해 조상 클래스의 생성자 호출
   
   * 오버라이딩(재정의, overriding)
     
     * 상위 클래스에 선언된 메서드를 자식 클래스에서 재정의 하는 것.
     
     * 메서드의 이름, 반환형, 매개변수(타입, 개수, 순서) 동일해야함
     
     * 하위 클래스의 접근제어자 범위가 상위 클래스보다 크거나 같아야 함
     
     * 조상보다 더 큰 예외 던질 수 X
     
     * 메서드 오버로딩(overloading)과 혼동X

2. Object
   
   * 가장 최상위 클래스로 모든 클래스의 조상
   
   * Object의 멤버는 모든 클래스의 멤버
   
   * toString 메서드
     
     * 객체를 문자열로 변경하는 메서드
   
   * equals 메서드
     
     * 두 객체가 같은지를 비교하는 메서드
     
     * 객체의 주소 비교 : == 활용
     
     * 객체의 내용 비교 : equals 재정의
   
   * hashCode
     
     * 객체의 해시 코드 : 시스템에서 객체 구별 위해 사용되는 정수 값
     
     * HashSet, HashMap 등에서 객체의 동일성 확인 위해 사용
     
     * equals 메서드를 재정의 할 때는 반드시 hashCode도 재정의 할 것
     
     * 미리 작성된 String이나 Number등에서 재정의 된 hashCode 활용 권장

## 7. final

----

1. final
   
   * 해당 선언이 최종 상태, 결코 수정될 수 없음
   
   * final 클래스 : 상속 금지
   
   * final 메서드 : overriding 금지
   
   * final 변수 : 더 이상 값을 바꿀 수 없음 상수화
